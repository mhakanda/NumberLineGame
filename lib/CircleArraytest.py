from psychopy import visual, event
import math, random, sys,wx

# constants
PI = 3.141592654
#sizeFactor = 1##1
#spacingFactor = 0.6
#colorScheme = 1
#sizingScheme = 3#3
corr = 1
#totalCirc = sizeFactor * 0.075 * 4440
##totalArea = (sizeFactor ** 2) * 20535

# Generates dots of random sizes
# A certain number of dots (specified by numDots) are initially generated by selected random values
# between minSize and maxSize from the distribution specified by distribution.  The sizes of the dots
# are then scaled so that they sum to the totalSize parameter.
# Parameters:
# minSize: the minimum pre-scaling dot size
# maxSize: the maximum pre-scaling dot size
# totalSize: the required post-scaling total dot size
# numDots: the number of dot radii generated
# sizeMeasure: either 'radius' or 'area'; determines which measure of a dot's size will be used as the
#   basis for the distribution from which dot sizes are chosen.  Default: 'radius'
# totalMeasure: either 'radius' or 'area'; determines which measure or a dot's size will be used to
#   control for the combined size of all the dots.  Default: 'radius'
# distribution: the distribution from which dot sizes are originally picked.  Currently, the only
#   supported distribution is the uniform distribution.  Default: 'uniform'

def generateDotRadii(minSize, maxSize, totalSize, numDots,
   sizeMeasure = 'radius', totalMeasure = 'radius', distribution = 'uniform'):

   # constants
   PI = 3.141592654

   # Check that parameters are correct
   if not (sizeMeasure == 'radius' or sizeMeasure == 'area'):
      raise ValueError('size must be measured based on radius or area')
   if not (totalMeasure == 'radius' or totalMeasure == 'area'):
      raise ValueError('total must be measured based on radius or area')
   if not distribution == 'uniform':
      raise ValueError('distribution must be uniform')

   # Handle different distributions
   if (distribution == 'uniform'):

      # Handle different measures of total area
      if totalMeasure == 'radius':

         # Handle different measures of circle size
            if sizeMeasure == 'radius':
                # fill a list with circle radii
                radii = [random.uniform(minSize, maxSize) for i in range(numDots)]
                # scale
                radii = [radius / sum(radii) * totalSize for radius in radii]
                return radii

            elif sizeMeasure == 'area':
                # fill a list with circles areas
                areas = [random.uniform(minSize, maxSize) for i in range(numDots)]
                # Convert to radii
                radii = [math.sqrt(area) / PI for area in areas]
                # scale
                radii = [radius / sum(radii) * totalSize for radius in radii]
                return radii


      elif totalMeasure == 'area':

         # Handle different measures of circle size
            if sizeMeasure == 'radius':
                # fill a list with circle radii
                radii = [random.uniform(minSize, maxSize) for i in range(numDots)]
                # convert to areas
                areas = [PI * radius ** 2 for radius in radii]
                # scale
                areas = [area / sum(areas) * totalSize for area in areas]
                # convert back to radii
                radii = [math.sqrt(area) / PI for area in areas]
                return radii

            elif sizeMeasure == 'area':
                # fill a list with circles areas
                areas = [random.uniform(minSize, maxSize) for i in range(numDots)]
                # scale
                areas = [area / sum(areas) * totalSize for area in areas]
                # Convert to radii
                radii = [math.sqrt(area) / PI for area in areas]
                return radii

def isOverlap(xLoc, yLoc, dotSizes):

    for i in range(1, len(dotSizes)):
        for j in range(i):
             if math.sqrt((xLoc[i] - xLoc[j])**2 + (yLoc[i] - yLoc[j])**2) <= dotSizes[i] + dotSizes[j]:
                    return True

    return False


# Picks the positions at which dots can appear in the window
# Parameters:
# xStart: leftmost location at which dots can appear
# xStop: rightmost location at which dots can appear
# yStart: lowest location at which dots can appear
# yStop: highest location at which dots can appear
# dotSizes: list of dot radii that need to be assigned locations
# xDist: distribution type from which to select x-values
# yDist: distribution type from which to select y-values
# canOverlap: True-->dots can overlap when drawn; False-->dots cannot overlap when drawn
#   and the function will be called again if they do.
def generateDotLocations(xStart, xStop, yStart, yStop, dotSizes, xDist = 'uniform', yDist = 'uniform',
   canOverlap = True):

    # constants
    PI = 3.141592654

    # Check parameters
    if not xDist == 'uniform' or not yDist == 'uniform':
        raise ValueException('xDist and yDist must be one of: \'uniform\'')

    # generate locations
    if xDist == 'uniform':
        xLoc = [random.uniform(xStart + dotSizes[i], xStop - dotSizes[i]) for i in range(len(dotSizes))]
    if yDist == 'uniform':
        yLoc = [random.uniform(yStart + dotSizes[i], yStop - dotSizes[i]) for i in range(len(dotSizes))]

    # If necessary, test to make sure no circles overlap
    overlapping = (xLoc, yLoc, dotSizes)

    # If some do, try again
    if overlapping and not canOverlap:
        return generateDotLocations(xStart, xStop, yStart, yStart, dotSizes, xDist, yDist, canOverlap)

    return [xLoc, yLoc]


def generateDotLocations1(xStart, xStop, yStart, yStop, dotSizes, pf,
    canOverlap = False, attempt = 0, tries = 1000):

    # Calculate number of dots
    num = len(dotSizes)
    if num == 0:
        return [[],[]];

    # Compute nearest square factorization
    yNum = int(math.ceil(math.sqrt(num)))
    xNum = yNum

    # Lay out grid
    margin = max(dotSizes)
    if (xNum > 1):
        xJump = (xStop - xStart - 2*(margin)) / (xNum - 1)
    if (yNum > 1):
        yJump = (yStop - yStart - 2*(margin)) / (yNum - 1)

    # Allow for movements in positive and negative directions
    xLoc = []
    if (xNum > 1) :
        for d in range(yNum):
            xLoc.extend([xStart + margin + random.uniform(0, xJump/pf)])
            xLoc.extend([xStart + margin + i * xJump + random.uniform(-xJump/pf, xJump/pf) for i in range(1,xNum-1)])
            xLoc.extend([xStart + margin + (xNum - 1) * xJump + random.uniform(-xJump/pf, 0)])
    else:
        xLoc = [random.uniform(xStart + margin, xStop - margin)]
    yLoc = []
    if (yNum > 1) :
        yLoc.extend([yStart + margin + random.uniform(0, yJump/pf) for d in range(xNum)])
        for i in range(1, yNum-1):
            yLoc.extend([yStart + margin + i * yJump + random.uniform(-yJump/pf, yJump/pf) for d in range(xNum)])
        yLoc.extend([yStart + margin + (yNum - 1) * yJump + random.uniform(-yJump/pf, 0) for d in range(xNum)])
    else:
        yLoc = [random.uniform(yStart + margin, yStop - margin)]

    # Remove random circles
    if (xNum > 1):
        ind = random.sample(xrange(len(xLoc)), num)
        xLoc = [xLoc[i] for i in ind]
        yLoc = [yLoc[i] for i in ind]

        # Check if overlapping occurs
        if not canOverlap:
            while (isOverlap(xLoc, yLoc, dotSizes) and attempt <= tries):
                attempt = attempt + 1
                xLoc = []
                for d in range(yNum):
                    xLoc.extend([xStart + margin + random.uniform(0, xJump/pf)])
                    xLoc.extend([xStart + margin + i * xJump + random.uniform(-xJump/pf, xJump/pf) for i in range(1,xNum-1)])
                    xLoc.extend([xStart + margin + (xNum - 1) * xJump + random.uniform(-xJump/pf, 0)])
                yLoc = []
                yLoc.extend([yStart + margin + random.uniform(0, yJump/pf) for d in range(xNum)])
                for i in range(1, yNum-1):
                    yLoc.extend([yStart + margin + i * yJump + random.uniform(-yJump/pf, yJump/pf) for d in range(xNum)])
                yLoc.extend([yStart + margin + (yNum - 1) * yJump + random.uniform(-yJump/pf, 0) for d in range(xNum)])
                ind = random.sample(xrange(len(xLoc)), num)
                xLoc = [xLoc[i] for i in ind]
                yLoc = [yLoc[i] for i in ind]



    return [xLoc, yLoc]

# Generates dot locations with the guarantee that the dots will not overlap
# Note that the returned locations correspond to dots in dotSizes in SORTED ORDER
def generateDotLocations2(xStart, xStop, yStart, yStop, dotSizes, tries = 1000):

    # Sort dots
    sortedSizes = sorted(dotSizes)

    # create new lists to hold locations
    xLoc = [0] * len(sortedSizes)
    yLoc = [0] * len(sortedSizes)

    # Loop through dots and generate locations for each of them
    for i in range(len(sortedSizes)):

        # Number of remaining tries
        remainingStarts = tries
        # Whether the dot has been successfully placed
        placed = False

        while not placed and remainingStarts > 0:

            xLoc[i] = random.uniform(xStart + sortedSizes[i] + 0.05, xStop - sortedSizes[i] - 0.05)
            yLoc[i] = random.uniform(yStart + sortedSizes[i] + 0.05, yStop - sortedSizes[i] - 0.05)

#            # Give us an opportunity to massage the dot location
#            remainingMoves = tries
#
#            # Move the dot somewhat intelligently
#            while not placed and remainingMoves > 0:
#
#                # Test for overlap
#                for j in range(i):
#                    # If they overlap, perturb the locations a little
#                    if math.sqrt((xLoc[i] - xLoc[j])**2 + (yLoc[i] - yLoc[j])**2) <= sortedSizes[i] + sortedSizes[j]:
#                        dx = random.uniform(0.05, 0.2) / (xLoc[i] - xLoc[j])
#                        dy = random.uniform(0.05, 0.2) / (yLoc[i] - yLoc[j])
#                        remainingMoves = remainingMoves - 1
#                        xLoc[i] = xStart + sortedSizes[i] + (xLoc[i] + math.copysign(dx, xLoc[i] - xLoc[j])) % (xStop - 2*sortedSizes[i] - xStart)
#                        yLoc[i] = yStart + sortedSizes[i] + (yLoc[i] + math.copysign(dy, yLoc[i] - yLoc[j])) % (yStop - 2*sortedSizes[i] - yStart)
#                        break
#                else:
#                    placed = True

            # Test for overlap
            for j in range(i):
                    # If they overlap, perturb the locations a little
                    if math.sqrt((xLoc[i] - xLoc[j])**2 + (yLoc[i] - yLoc[j])**2) <= sortedSizes[i] + sortedSizes[j]:
                        remainingStarts = remainingStarts - 1
                        break
            else:
                placed = True

        # Alert user if we can't find a way to place the dots without overlapping
        if remainingStarts <= 0:
            # Search systematically for a spot for the dotLocations
            xLoc[i] = xStart + sortedSizes[i]
            yLoc[i] = yStart + sortedSizes[i]
            foundOne = False
            while xLoc[i] < xStop - sortedSizes[i] and not foundOne:
                while yLoc[i] < yStop - sortedSizes[i] and not foundOne:

                    # Test for overlap
                    for j in range(i):
                        # If they overlap, check the next spot
                        if math.sqrt((xLoc[i] - xLoc[j])**2 + (yLoc[i] - yLoc[j])**2) <= sortedSizes[i] + sortedSizes[j]:
                            yLoc[i] = yLoc[i] + 0.01
                            break
                    else:
                        foundOne = True

                if not foundOne:
                    xLoc[i] = xLoc[i] + 0.01
                    yLoc[i] = yStart + sortedSizes[i]

            if not foundOne:
                raise AttributeError('Could not place a dot')

    return [xLoc, yLoc]

#w is the window
#numerator is the numerator
#denominator is the denominator
#position is [center_x,center_y], an example position = [0,0]
# color = [NDotColor,NBoxColor,NLineColor,DDotColor,DBoxColor,DLineColor]
#an example color =['green',None,'black','red',None,'Black']
# parameter = [isBoundingBox,sizeFactor = 1,spacingFactor = 0.6,sizingScheme = 3]
#isBoundingBox is 0 or 1, 1 for bounding box around dots
#sizeFactor is how small or big the whole things are, usuallay between 1 to 2
#an example parameter = [1,1.3,0.6,3]
#enclosed  is 0 or 1, 1 is for needing coordinate for bounding box as [width,height,x-center,y-center]
#if enclosed = 1, then it returns [list_of_all_dots_and_boundingbox_if_necessary,list_of_bounding_box_coordinate]
#if enclosed  = 0, then it returns list_of_all_dots_and_boundingbox_if_necessary

def makeArray(w,numerator, denominator,position,color,parameter,enclosed):
    # parameter = [isBoundingBox, sizeFactor = 1, spacingFactor = 0.6, sizingScheme = 3]
    sizeFactor = parameter[1]
    xCenter = position[0]
    yCenter = position[1]
    spacingFactor = parameter[2]
    sizingScheme = parameter[3]
    isBoundingBox = parameter[0]
    totalCirc = sizeFactor * 0.075 * 4440
    totalArea = (sizeFactor ** 2) * 20535

    # Dot box for numerator
    topn = sizeFactor * 200 + yCenter
    bottomn = sizeFactor * 0 + yCenter
    leftn = - sizeFactor * 100 + xCenter
    rightn = sizeFactor * 100 + xCenter
    # Dot box for denominator
    topd = sizeFactor * 0 + yCenter
    bottomd = -sizeFactor * 200 + yCenter
    leftd = -sizeFactor * 100 + xCenter
    rightd = sizeFactor * 100 + xCenter

    # Perturbation factor:
    pf = 3.7

    # Determine parameters for array
    # Colors
    # color = [NDotColor, NBoxColor, NLineColor, DDotColor, DBoxColor, DLineColor]

    numeratorBoxColor = color[1]  # '#ccc'#"white"
    numeratorLineColor = color[2]  # '#ccc'#"white"
    numeratorDotColor = color[0]
    denominatorBoxColor = color[4]  # '#ccc'#"Black"
    denominatorLineColor = color[5]  # '#ccc'#"Black"
    denominatorDotColor = color[3]

    # Dot sizingScheme
    if sizingScheme == 1:
        sizeM = 'radius'
        totalM = 'radius'
        minS = sizeFactor * 0.15
        maxS = sizeFactor * 0.15
        totalSn = numerator * minS
        totalSd = denominator * minS
    elif sizingScheme == 2:
        sizeM = 'radius'
        totalM = 'radius'
        minS = sizeFactor * 0.075
        maxS = sizeFactor * 0.075
        totalSn = totalCirc
        totalSd = totalCirc
    else: #sizingScheme == 3
        sizeM = 'radius'
        totalM = 'area'
        minS = sizeFactor * 0.1
        maxS = sizeFactor * 0.2
        totalSn = totalArea
        totalSd = totalArea

    # generate dot radius sizes and locations
    # Numerator
    if numerator > 0:
        dotSizesn = generateDotRadii(minSize = minS, maxSize = maxS, totalSize = totalSn, sizeMeasure = sizeM, totalMeasure = totalM, numDots = numerator)
        dotLocationsn = generateDotLocations1(leftn, rightn, bottomn, topn, dotSizesn, pf,
            canOverlap = False, attempt = 0, tries = 100)
        # Rescale to prevent touching
        if sizingScheme == 3:
            dotSizesn = [math.sqrt((dot ** 2) * spacingFactor) for dot in dotSizesn]
        else:
            dotSizesn = [dot * spacingFactor for dot in dotSizesn]

    # Denominator
    dotSizesd = generateDotRadii(minSize = minS, maxSize = maxS, totalSize = totalSd, sizeMeasure = sizeM, totalMeasure = totalM, numDots = denominator)
    dotLocationsd = generateDotLocations1(leftd, rightd, bottomd, topd, dotSizesd, pf,
        canOverlap = False, attempt = 0, tries = 1000)
    if sizingScheme == 3:
        dotSizesd = [math.sqrt((dot ** 2) * spacingFactor) for dot in dotSizesd]
    else:
        dotSizesd = [dot * spacingFactor for dot in dotSizesd]

    # zip into triples (radius, xLocation, yLocation)
    # Note that dot sizes must be sorted if method 2 is used
    # to generate locations
    if numerator > 0:
        dotsn = zip(dotSizesn, dotLocationsn[0], dotLocationsn[1])
    else:
        dotsn = []
    dotsd = zip(dotSizesd, dotLocationsd[0], dotLocationsd[1])


    # Create bounding box
    if(isBoundingBox):
        boundingBoxn = visual.Rect(win = w, pos = (xCenter, yCenter + topn / 2-position[1]/2.), width = rightn - leftn, height = topn - bottomn, lineColor = numeratorLineColor, fillColor = numeratorBoxColor, lineWidth = 2)
        boundingBoxd = visual.Rect(win = w, pos = (xCenter, yCenter + bottomd / 2-position[1]/2.), width = rightd - leftd, height = topd - bottomd, lineColor = denominatorLineColor, fillColor = denominatorBoxColor, lineWidth = 2)
        boundingBoxn.autoDraw = True
        boundingBoxd.autoDraw = True
    #print rightn - leftn, rightd - leftd,topn - bottomn,topd - bottomd

    # Plot circles
    circlesn = []
    circlesd = []
    for (rad, xLoc, yLoc) in dotsn:
        circlesn.append(visual.Circle(win = w, radius = rad, pos = (xLoc, yLoc), lineColor = numeratorDotColor, fillColor = numeratorDotColor))
    for (rad, xLoc, yLoc) in dotsd:
        circlesd.append(visual.Circle(win = w, radius = rad, pos = (xLoc, yLoc), lineColor = denominatorDotColor, fillColor = denominatorDotColor))



    for circle in circlesn:
        circle.autoDraw = True
    for circle in circlesd:
        circle.autoDraw = True

    w.flip()
    if (isBoundingBox):
        tR = [boundingBoxn, boundingBoxd] + circlesn + circlesd
    else:
        tR = circlesn + circlesd

    if (enclosed):
        cor = [rightn - leftn, topn - bottomn+topd - bottomd, position[0], position[1]]
        return [tR, cor]
    else:
        return tR
#-----------------------------------------
# #------------------------------
# BACKGROUND = '#ccc'
# ipt = wx.App(False)
# WIDTH = wx.GetDisplaySize()[0]
# HEIGHT = wx.GetDisplaySize()[1]
# print WIDTH,HEIGHT
# p = WIDTH  # WIDTH
# ww, hh = p, p * HEIGHT / float(WIDTH)
# w = visual.Window(size=(ww, hh), color=BACKGROUND, monitor="testMonitor", units="pix")
# window,stim,num,den = w,'array',10,0
# numc,denc = 'white','black'
# position = (20,-10)
# color = [numc,denc,denc,denc,numc,numc]
# color = [None,None,None,denc,numc,numc]
# color = [numc,denc,denc,None,None,None]
#parameter = [isBoundingBox,sizeFactor = 1,spacingFactor = 0.6,sizingScheme = 3]
parameter = [1,.9,0.6,3]#sizeFactor = .9 to 1.2
enclosed = 0
# cc = makeArray(window,num, den,position,color,parameter,enclosed)
#t1 = visual.Rect(win=w, width=50, height=1, pos=position, lineColor="black")
#t2 = visual.Rect(win=w, width=1, height=50, pos=position, lineColor="black")
    # t3 = visual.Rect(win=w, width=cc[1][0]+20, height=cc[1][1]+20, pos=position, lineColor="red")
#t1.autoDraw = 1
#t2.autoDraw = 1
    # t3.autoDraw = 1
# print cc[1]
# w.flip()
# event.waitKeys()
